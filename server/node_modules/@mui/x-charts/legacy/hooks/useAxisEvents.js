import * as React from 'react';
import { InteractionContext } from '../context/InteractionProvider';
import { CartesianContext } from '../context/CartesianContextProvider';
import { SVGContext, DrawingContext } from '../context/DrawingProvider';
import { isBandScale } from '../internals/isBandScale';
export var useAxisEvents = function useAxisEvents(disableAxisListener) {
  var svgRef = React.useContext(SVGContext);
  var _React$useContext = React.useContext(DrawingContext),
    width = _React$useContext.width,
    height = _React$useContext.height,
    top = _React$useContext.top,
    left = _React$useContext.left;
  var _React$useContext2 = React.useContext(CartesianContext),
    xAxis = _React$useContext2.xAxis,
    yAxis = _React$useContext2.yAxis,
    xAxisIds = _React$useContext2.xAxisIds,
    yAxisIds = _React$useContext2.yAxisIds;
  var _React$useContext3 = React.useContext(InteractionContext),
    dispatch = _React$useContext3.dispatch;
  var usedXAxis = xAxisIds[0];
  var usedYAxis = yAxisIds[0];

  // Use a ref to avoid rerendering on every mousemove event.
  var mousePosition = React.useRef({
    x: -1,
    y: -1
  });
  React.useEffect(function () {
    var element = svgRef.current;
    if (element === null || disableAxisListener) {
      return function () {};
    }
    var getUpdateY = function getUpdateY(y) {
      if (usedYAxis === null) {
        return null;
      }
      var _yAxis$usedYAxis = yAxis[usedYAxis],
        yScale = _yAxis$usedYAxis.scale,
        yAxisData = _yAxis$usedYAxis.data;
      if (!isBandScale(yScale)) {
        return {
          value: yScale.invert(y)
        };
      }
      var dataIndex = Math.floor((y - yScale.range()[0]) / yScale.step());
      if (dataIndex < 0 || dataIndex >= yAxisData.length) {
        return null;
      }
      return {
        index: dataIndex,
        value: yAxisData[dataIndex]
      };
    };
    var getUpdateX = function getUpdateX(x) {
      if (usedXAxis === null) {
        return null;
      }
      var _xAxis$usedXAxis = xAxis[usedXAxis],
        xScale = _xAxis$usedXAxis.scale,
        xAxisData = _xAxis$usedXAxis.data;
      if (!isBandScale(xScale)) {
        var value = xScale.invert(x);
        var closestIndex = xAxisData == null ? void 0 : xAxisData.findIndex(function (v, index) {
          if (v > value) {
            // @ts-ignore
            if (index === 0 || Math.abs(value - v) <= Math.abs(value - xAxisData[index - 1])) {
              return true;
            }
          }
          if (v <= value) {
            if (index === xAxisData.length - 1 ||
            // @ts-ignore
            Math.abs(value - v) < Math.abs(value - xAxisData[index + 1])) {
              return true;
            }
          }
          return false;
        });
        return {
          value: closestIndex !== undefined && closestIndex >= 0 ? xAxisData[closestIndex] : value,
          index: closestIndex
        };
      }
      var dataIndex = xScale.bandwidth() === 0 ? Math.floor((x - xScale.range()[0] + xScale.step() / 2) / xScale.step()) : Math.floor((x - xScale.range()[0]) / xScale.step());
      if (dataIndex < 0 || dataIndex >= xAxisData.length) {
        return null;
      }
      return {
        index: dataIndex,
        value: xAxisData[dataIndex]
      };
    };
    var handleMouseOut = function handleMouseOut() {
      mousePosition.current = {
        x: -1,
        y: -1
      };
      dispatch({
        type: 'updateAxis',
        data: {
          x: null,
          y: null
        }
      });
    };
    var handleMouseMove = function handleMouseMove(event) {
      // Get mouse coordinate in global SVG space
      var pt = svgRef.current.createSVGPoint();
      pt.x = event.clientX;
      pt.y = event.clientY;
      var svgPt = pt.matrixTransform(svgRef.current.getScreenCTM().inverse());
      mousePosition.current = {
        x: svgPt.x,
        y: svgPt.y
      };
      var outsideX = svgPt.x < left || svgPt.x > left + width;
      var outsideY = svgPt.y < top || svgPt.y > top + height;
      if (outsideX || outsideY) {
        dispatch({
          type: 'updateAxis',
          data: {
            x: null,
            y: null
          }
        });
        return;
      }
      var newStateX = getUpdateX(svgPt.x);
      var newStateY = getUpdateY(svgPt.y);
      dispatch({
        type: 'updateAxis',
        data: {
          x: newStateX,
          y: newStateY
        }
      });
    };
    element.addEventListener('mouseout', handleMouseOut);
    element.addEventListener('mousemove', handleMouseMove);
    return function () {
      element.removeEventListener('mouseout', handleMouseOut);
      element.removeEventListener('mousemove', handleMouseMove);
    };
  }, [svgRef, dispatch, left, width, top, height, usedYAxis, yAxis, usedXAxis, xAxis, disableAxisListener]);
};