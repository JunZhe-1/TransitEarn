"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAxisEvents = void 0;
var React = _interopRequireWildcard(require("react"));
var _InteractionProvider = require("../context/InteractionProvider");
var _CartesianContextProvider = require("../context/CartesianContextProvider");
var _DrawingProvider = require("../context/DrawingProvider");
var _isBandScale = require("../internals/isBandScale");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const useAxisEvents = disableAxisListener => {
  const svgRef = React.useContext(_DrawingProvider.SVGContext);
  const {
    width,
    height,
    top,
    left
  } = React.useContext(_DrawingProvider.DrawingContext);
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = React.useContext(_CartesianContextProvider.CartesianContext);
  const {
    dispatch
  } = React.useContext(_InteractionProvider.InteractionContext);
  const usedXAxis = xAxisIds[0];
  const usedYAxis = yAxisIds[0];

  // Use a ref to avoid rerendering on every mousemove event.
  const mousePosition = React.useRef({
    x: -1,
    y: -1
  });
  React.useEffect(() => {
    const element = svgRef.current;
    if (element === null || disableAxisListener) {
      return () => {};
    }
    const getUpdateY = y => {
      if (usedYAxis === null) {
        return null;
      }
      const {
        scale: yScale,
        data: yAxisData
      } = yAxis[usedYAxis];
      if (!(0, _isBandScale.isBandScale)(yScale)) {
        return {
          value: yScale.invert(y)
        };
      }
      const dataIndex = Math.floor((y - yScale.range()[0]) / yScale.step());
      if (dataIndex < 0 || dataIndex >= yAxisData.length) {
        return null;
      }
      return {
        index: dataIndex,
        value: yAxisData[dataIndex]
      };
    };
    const getUpdateX = x => {
      if (usedXAxis === null) {
        return null;
      }
      const {
        scale: xScale,
        data: xAxisData
      } = xAxis[usedXAxis];
      if (!(0, _isBandScale.isBandScale)(xScale)) {
        const value = xScale.invert(x);
        const closestIndex = xAxisData?.findIndex((v, index) => {
          if (v > value) {
            // @ts-ignore
            if (index === 0 || Math.abs(value - v) <= Math.abs(value - xAxisData[index - 1])) {
              return true;
            }
          }
          if (v <= value) {
            if (index === xAxisData.length - 1 ||
            // @ts-ignore
            Math.abs(value - v) < Math.abs(value - xAxisData[index + 1])) {
              return true;
            }
          }
          return false;
        });
        return {
          value: closestIndex !== undefined && closestIndex >= 0 ? xAxisData[closestIndex] : value,
          index: closestIndex
        };
      }
      const dataIndex = xScale.bandwidth() === 0 ? Math.floor((x - xScale.range()[0] + xScale.step() / 2) / xScale.step()) : Math.floor((x - xScale.range()[0]) / xScale.step());
      if (dataIndex < 0 || dataIndex >= xAxisData.length) {
        return null;
      }
      return {
        index: dataIndex,
        value: xAxisData[dataIndex]
      };
    };
    const handleMouseOut = () => {
      mousePosition.current = {
        x: -1,
        y: -1
      };
      dispatch({
        type: 'updateAxis',
        data: {
          x: null,
          y: null
        }
      });
    };
    const handleMouseMove = event => {
      // Get mouse coordinate in global SVG space
      const pt = svgRef.current.createSVGPoint();
      pt.x = event.clientX;
      pt.y = event.clientY;
      const svgPt = pt.matrixTransform(svgRef.current.getScreenCTM().inverse());
      mousePosition.current = {
        x: svgPt.x,
        y: svgPt.y
      };
      const outsideX = svgPt.x < left || svgPt.x > left + width;
      const outsideY = svgPt.y < top || svgPt.y > top + height;
      if (outsideX || outsideY) {
        dispatch({
          type: 'updateAxis',
          data: {
            x: null,
            y: null
          }
        });
        return;
      }
      const newStateX = getUpdateX(svgPt.x);
      const newStateY = getUpdateY(svgPt.y);
      dispatch({
        type: 'updateAxis',
        data: {
          x: newStateX,
          y: newStateY
        }
      });
    };
    element.addEventListener('mouseout', handleMouseOut);
    element.addEventListener('mousemove', handleMouseMove);
    return () => {
      element.removeEventListener('mouseout', handleMouseOut);
      element.removeEventListener('mousemove', handleMouseMove);
    };
  }, [svgRef, dispatch, left, width, top, height, usedYAxis, yAxis, usedXAxis, xAxis, disableAxisListener]);
};
exports.useAxisEvents = useAxisEvents;